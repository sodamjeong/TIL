# 경쟁 상태(Race Condition), 교착상태 (DeadLock)


## 경쟁상태

- 경쟁 상태도 교착 상태의 종류 중에 하나
- 둘 이상의 스레드나 프로세스가 공유된 자원(예: 변수, 메모리 등)에 대해 동시에 접근하고 변경하는 경우 발생할 수 있는 문제 
- 어떤 스레드나 프로세스가 먼저 접근하여 변경한 값을 다른 스레드나 프로세스가 무시하거나, 올바르지 않은 값을 사용하는 등의 문제가 발생할 수 있음.

### 경쟁상태가 발생하는 경우

1. 커널 모드에서 데이터를 로드해 작업을 수행하다가 인터럽트가 발생해 같은 데이터를 조작하는 경우
2. 프로세스1이 커널모드에서 데이터를 조작하던 도중 시간이 초과되어 CPU 제어권이 프로세스2로 넘어가 같은 데이터를 조작하는 경우
3. 멀티프로세스 환경에서 2개의 CPU가 동시에 커널 내부의 공유 데이터에 접근하여 조작하는 경우
4. 멀티 스레드 환경에서 두개 이상의 스레드가 공통의 전역변수에 접근할 경우 

### 해결 방법

1. 커널 모드에서 작업을 수행하는 동안 인터럽트를 disable 시켜 CPU 제어권을 가져가지 못하도록 함
2. 프로세스가 커널모드에서 작업을 하는 경우에는 시간이 초과되더라도 CPU 제어권이 다른 프로세스에게 넘어가지 않도록 함
3. 커널 내부에 있는 각 공유 데이터에 접근할 때마다 그 데이터에 대해 lock/unlock 함

## 교착상태

- 둘 이상의 프로세스나 스레드가 서로 상대방의 자원을 사용하기 위해 대기하며, 프로세스가 원하는 자원을 얻지 못해 더 이상 진행할 수 없는 상태
- 블록 상태(Blocked State)에 머무르며, 시스템이 멈추거나 비정상적인 동작을 하게 됨.

### 교착상태가 발생하는 조건 (모두 성립 해야함)

1. 상호 배제 (Mutual exclusion)
  - 자원은 한번에 한 프로세스만 사용할 수 있다. 사용중인 자원을 다른 프로세스가 사용하려면 요청한 자원이 해제될 때까지 기다려야 한다.

2. 점유 대기 (Hold and Wait)
  - 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야 한다. 

3. 비선점 (No preemption)
  - 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없음

4. 순환 대기(Circular wait)
  - 대기 프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 한다.

```하나라도 성립하지 않으면 해결 가능```

### 해결 방법

1. 예방 : 교착 상태를 유발하는 4가지 조건 중 하나를 제거하면서 해결. (자원 낭비가 심함)
2. 회피 : 교착 상태가 발생 조건을 없애는 것 보다는 애초에 교착 상태가 발생하지 않도록 알고리즘을 적용하는 방법.
3. 검출 : 탐지 알고리즘 및 자원 할당 그래프를 사용해 교착 상태를 발견하고 탐지 되면 복구 기법을 통해 복구. (지속적으로 확인이 필요하기 때문에 성능 저하 발생)
4. 회복 : 교착 상태를 일으킨 프로세스를 종료하거나, 할당된 자원을 해제시켜 회복.
